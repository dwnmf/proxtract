Тема: План развития инструмента Proxtract

Привет. Я проанализировал текущую версию Proxtract и подготовил план по дальнейшему развитию. Проект уже самодостаточен, но следующие задачи помогут сделать его еще более мощным и удобным для пользователей.

Задача 1: Интеграция с файлами .gitignore

Цель: Автоматически исключать файлы и директории, указанные в .gitignore, чтобы результат извлечения был более чистым и релевантным.

Субзадача 1.1: Исследовать и выбрать библиотеку для парсинга .gitignore. Необходимо найти легковесное и надежное решение. Рассмотри `pathspec` или аналоги.

Субзадача 1.2: Реализовать логику обнаружения и загрузки правил. В классе `FileExtractor` нужно добавить метод, который ищет .gitignore в корневой директории проекта и парсит его содержимое.

Субзадача 1.3: Интегрировать проверку правил в основной цикл фильтрации. Модифицируй метод `_should_skip`, чтобы он проверял каждый путь на соответствие правилам из .gitignore.

Субзадача 1.4: Добавить настройку для управления этой функцией. В `AppState` и команду `/settings` нужно добавить опцию `use_gitignore` (по умолчанию `on`), чтобы пользователь мог отключить это поведение.

Задача 2: Реализация неинтерактивного режима работы (CLI)

Цель: Позволить использовать Proxtract в автоматизированных скриптах и CI/CD пайплайнах путем вызова из командной строки с аргументами.

Субзадача 2.1: Интегрировать парсер аргументов командной строки. Добавь в `main.py` библиотеку `argparse` или `click` для обработки CLI-аргументов.

Субзадача 2.2: Определить CLI-аргументы. Нужно создать аргументы, которые дублируют функциональность REPL: `extract <path>`, `--output <file>`, `--max-size <kb>`, `--compact <on|off>` и так далее.

Субзадача 2.3: Разделить логику запуска. В `main.py` необходимо реализовать проверку: если переданы аргументы командной строки, запустить извлечение напрямую и завершить работу. Если аргументов нет, запустить интерактивную сессию, как сейчас.

Субзадача 2.4: Адаптировать логику извлечения. Необходимо убедиться, что функция `cmd_extract` или ее ядро может быть вызвана как из REPL с состоянием сессии, так и напрямую с параметрами из CLI.

Задача 3: Поддержка пользовательских правил фильтрации

Цель: Дать пользователям возможность определять собственные правила для включения или исключения файлов, помимо стандартных.

Субзадача 3.1: Спроектировать и реализовать хранение правил. Расширь `AppState`, добавив списки для пользовательских glob-паттернов, например, `include_patterns` и `exclude_patterns`.

Субзадача 3.2: Создать команды для управления правилами. Реализуй новые REPL-команды, например, `/include "**/*.js"` и `/exclude "**/node_modules/**"`, а также команду `/rules` для просмотра текущих правил.

Субзадача 3.3: Обновить логику фильтрации. В методе `_should_skip` добавь логику, которая применяет пользовательские правила. Установи четкий приоритет: пользовательские правила должны иметь больший вес, чем встроенные.

Задача 4: Сохранение конфигурации между сессиями

Цель: Сделать так, чтобы настройки пользователя (размер файла, путь вывода, пользовательские правила) сохранялись после перезапуска приложения.

Субзадача 4.1: Реализовать загрузку конфигурации. При запуске `AppState` должна проверять наличие файла конфигурации (например, `~/.config/proxtract/settings.toml`) и загружать из него настройки.

Субзадача 4.2: Реализовать сохранение конфигурации. Создай команду `/settings save` или добавь автоматическое сохранение настроек при выходе из REPL, чтобы текущее состояние сессии записывалось в файл.

Субзадача 4.3: Определить приоритет настроек. Установи следующий порядок приоритета: аргументы CLI > настройки сессии REPL > настройки из файла конфигурации > значения по умолчанию.

Задача 5: Подсчет количества токенов

Цель: Предоставить пользователю оценку количества токенов в итоговом файле, чтобы он мог понимать, поместится ли результат в контекстное окно LLM.

Субзадача 5.1: Интегрировать библиотеку для токенизации. Добавь `tiktoken` как опциональную зависимость.

Субзадача 5.2: Реализовать подсчет токенов. В процессе извлечения файлов в `FileExtractor` суммируй количество токенов из каждого обработанного файла.

Субзадача 5.3: Отобразить результат. Добавь поле `total_tokens` в `ExtractionStats` и выводи его в итоговой таблице после завершения экстракции.

Субзадача 5.4: Добавить настройку модели. Реализуй в `/settings` возможность выбора модели токенизации (например, `gpt-4`), так как правила токенизации отличаются.

Задача 6: Функция копирования результата в буфер обмена

Цель: Упростить процесс передачи извлеченного текста в LLM, добавив возможность скопировать его напрямую в буфер обмена.

Субзадача 6.1: Добавить зависимость для работы с буфером обмена. Интегрируй кроссплатформенную библиотеку, например, `pyperclip`.

Субзадача 6.2: Модифицировать команду извлечения. Добавь флаг для команды `/extract`, например, `/extract . --copy`, который активирует копирование.

Субзадача 6.3: Реализовать логику копирования. После успешного создания итогового файла, если флаг был указан, прочитай содержимое файла и помести его в системный буфер обмена.

Субзадача 6.4: Обеспечить обратную связь. После копирования выведи в консоль подтверждающее сообщение, например, "Результат извлечен и скопирован в буфер обмена". На каждом этапе тестируй через smoke тесты.